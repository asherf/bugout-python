import logging
from typing import Any, Dict, List, Optional, Tuple

from .calls import make_request, InvalidUrlSpec
from .data import BugoutUser, BugoutToken, Method, TokenType

logger = logging.getLogger(__name__)


class UserNotFound(Exception):
    """
    Raised on actions that involve user which are not present in the database.
    """


class TokenInvalidParameters(ValueError):
    """
    Raised when operations are applied to a token but invalid parameters are provided with which to
    specify that token.
    """


class User:
    """
    Represent a user from Bugout.
    """

    def __init__(self, url: Optional[str] = None) -> None:
        if url is None:
            raise InvalidUrlSpec("Invalid brood url specified")
        self.url = url

    def _call(self, method: Method, path: str, **kwargs):
        url = f"{self.url.rstrip('/')}/{path.rstrip('/')}"
        result = make_request(method=method, url=url, **kwargs)
        return result

    def _user_model_converter(self, user_object: Dict[str, Any]) -> BugoutUser:
        return BugoutUser(
            id=user_object.get("user_id"),
            username=user_object.get("username"),
            email=user_object.get("email"),
            normalized_email=user_object.get("normalized_email"),
            verified=user_object.get("verified"),
            autogenerated=user_object.get("autogenerated"),
            created_at=user_object.get("created_at"),
            updated_at=user_object.get("updated_at"),
        )

    def get_user(self, token: str) -> Dict[str, Any]:
        get_user_path = "user"
        headers = {
            "Authorization": f"Bearer {token}",
        }
        result = self._call(method=Method.get, path=get_user_path, headers=headers)
        return self._user_model_converter(result)

    def create_user(
        self,
        username: str,
        email: str,
        password: str,
        autogenerated_token: Optional[str] = None,
    ) -> Dict[str, Any]:
        create_user_path = "user"
        data = {
            "username": username,
            "email": email,
            "password": password,
        }
        headers = None
        if autogenerated_token is not None:
            headers = {
                "x-bugout-installation-token": autogenerated_token,
            }
        result = self._call(
            method=Method.post, path=create_user_path, headers=headers, data=data
        )
        return self._user_model_converter(result)

    def create_token(self, username: str, password: str) -> BugoutToken:
        create_token_path = "token"
        data = {
            "username": username,
            "password": password,
        }
        result = self._call(method=Method.post, path=create_token_path, data=data)
        return BugoutToken(
            id=result.get("access_token"),
            token_type=result.get("token_type"),
        )

    def revoke_token(self, token: str) -> BugoutToken:
        create_token_path = "token"
        headers = {
            "Authorization": f"Bearer {token}",
        }
        result = self._call(
            method=Method.delete, path=create_token_path, headers=headers
        )
        return BugoutToken(id=result)

    def update_token(
        self,
        token: str,
        token_type: Optional[str] = None,
        token_note: Optional[str] = None,
    ) -> BugoutToken:
        create_token_path = "token"

        data = {"access_token": token}
        if token_type is None and token_note is None:
            raise TokenInvalidParameters(
                "In order to update token, at least one of token_type, or token_note must be specified"
            )
        if token_type not in TokenType.__members__:
            raise TokenInvalidParameters("Incorrect token type provided")

        if token_type is not None:
            data.update({"token_type": token_type})
        if token_note is not None:
            data.update({"token_note": token_note})

        result = self._call(method=Method.put, path=create_token_path, data=data)
        return BugoutToken(id=result, token_type=token_type, token_note=token_note)
